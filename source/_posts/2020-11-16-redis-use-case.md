---
title: Redis修炼之使用场景
date: 2020-11-16 00:33:06
tags: 
- Redis
- Redis使用场景
categories: 
- 数据库
- Redis修炼
---



> ## 前言

接着Redis数据类型来说，来谈谈Redis的具体使用场景，首先回顾一下：

Redis是一种基于键值对的NoSQL数据库，它的值主要由string（字符串），hash（哈希），list（列表），set（集合），zset（有序集合）五种基本数据结构构成。那么这些数据结构的使用场景有哪些？以下将用内部编码及使用场景的方式浅析Redis的五种数据类型。

<!-- more -->


> ## 使用场景



### **一 字符串**

字符串类型是Redis最基础的数据结构，字符串类型可以是`JSON`、`XML`甚至是二进制的图片等数据，但是最大值不能超过512MB。



#### **1.1 内部编码**

Redis会根据当前值的类型和长度决定使用哪种内部编码来实现。

字符串类型的内部编码有3种：

- int：8个字节的长整型。
- embstr：小于等于39个字节的字符串。
- raw：大于39个字节的字符串。



#### **1.2 使用场景**

##### 1.2.1 缓存

在web服务中，使用MySQL作为数据库，Redis作为缓存。由于Redis具有支撑高并发的特性，通常能起到加速读写和降低后端压力的作用。web端的大多数请求都是从Redis中获取的数据，如果Redis中没有需要的数据，则会从MySQL中去获取，并将获取到的数据写入redis。

##### 1.2.2 计数

Redis中有一个字符串相关的命令`incr key`，`incr`命令对值做自增操作，返回结果分为以下三种情况：

- 值不是整数，返回错误
- 值是整数，返回自增后的结果
- key不存在，默认键为`0`，返回`1`

比如文章的阅读量，视频的播放量等等都会使用redis来计数，每播放一次，对应的播放量就会加1，同时将这些数据异步存储到数据库中达到持久化的目的。

##### 1.2.3 共享Session

在分布式系统中，用户的每次请求会访问到不同的服务器，这就会导致session不同步的问题，假如一个用来获取用户信息的请求落在A服务器上，获取到用户信息后存入session。下一个请求落在B服务器上，想要从session中获取用户信息就不能正常获取了，因为用户信息的session在服务器A上，为了解决这个问题，使用redis集中管理这些session，将session存入redis，使用的时候直接从redis中获取就可以了。

##### 1.2.4 限速

为了安全考虑，有些网站会对IP进行限制，限制同一IP在一定时间内访问次数不能超过n次。



### **二 哈希**

Redis中，哈希类型是指一个键值对的存储结构。

#### **2.1 内部编码**

哈希类型的内部编码有两种：

- ziplist（压缩列表）：当哈希类型元素个数小于`hash-max-ziplist-entries`配置（默认512个）同时所有值都小于`hash-max-ziplist-value`配置（默认64字节）时使用。ziplist使用更加紧凑的结构实现多个元素的连续存储，所以比hashtable更加节省内存。
- hashtable（哈希表）：当ziplist不能满足要求时，会使用hashtable。

#### **2.2 使用场景**

由于hash类型存储的是一个键值对，比如数据库有以下一个用户表结构

| id   | name | age  |
| :--- | :--- | :--- |
| 1    | 豆豆 | 24   |

将以上信息存入redis，用表明:id作为key，用户属性作为值：

```shell
hset user:1 name 豆豆 age 24
```

使用哈希存储会比字符串更加方便直观



### **三 列表**

列表类型用来存储多个**有序**的字符串，一个列表最多可以存储`2^32-1`个元素，列表的两端都可以插入和弹出元素。



#### **3.1 内部编码**

列表的内部编码有两种：

- ziplist（压缩列表）：当哈希类型元素个数小于`list-max-ziplist-entries`配置（默认512个）同时所有值都小于`list-max-ziplist-value`配置（默认64字节）时使用。ziplist使用更加紧凑的结构实现多个元素的连续存储，所以比hashtable更加节省内存。
- linkedlist（链表）：当ziplist不能满足要求时，会使用linkedlist。



#### **3.2 使用场景**

##### 3.2.1 消息队列

列表用来存储多个有序的字符串，既然是有序的，那么就满足消息队列的特点。使用`lpush`+`rpop`或者`rpush`+`lpop`实现消息队列。除此之外，redis支持阻塞操作，在弹出元素的时候使用阻塞命令来实现阻塞队列。

在蓝鲸SaaS开发中，Django的Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ、Redis等等。SaaS的本地开发中，Celery也默认选择了Redis作为消息队列。

```python
# Celery 消息队列设置 RabbitMQ
# BROKER_URL = 'amqp://guest:guest@localhost:5672//'
# Celery 消息队列设置 Redis
BROKER_URL = "redis://localhost:6379/0"
```



##### 3.2.2 栈

由于列表存储的是有序字符串，满足队列的特点，也就能满足栈先进后出的特点，使用`lpush`+`lpop`或者`rpush`+`rpop`实现栈。

##### 3.2.3 文章列表

因为列表的元素不但是有序的，而且还支持按照索引范围获取元素。因此我们可以使用命令`lrange key 0 9`分页获取文章列表



### **四 集合**

集合类型也可以保存多个字符串元素，与列表不同的是，集合中不允许有重复元素并且集合中的元素是无序的。一个集合最多可以存储`2^32-1`个元素。


#### **4.1 内部编码**

集合类型的内部编码有两种：

- intset（整数集合）：当集合中的元素都是整数且元素个数小于`set-max-intset-entries`配置（默认512个）时，redis会选用intset来作为集合的内部实现，从而减少内存的使用。
- hashtable（哈希表）：当intset不能满足要求时，会使用hashtable。


#### **4.2 使用场景**

##### 4.2.1 用户标签

例如一个用户对篮球、足球感兴趣，另一个用户对橄榄球、乒乓球感兴趣，这些兴趣点就是一个标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同感兴趣的标签。给用户打标签的时候需要①给用户打标签，②给标签加用户，需要给这两个操作增加事务。

- 给用户打标签

```
sadd user:1:tags tag1 tag2
```

- 给标签添加用户

```
sadd tag1:users user:1
sadd tag2:users user:1
```

使用交集（sinter）求两个user的共同标签

```
sinter user:1:tags user:2:tags
```

##### 4.2.2 抽奖功能

集合有两个命令支持获取随机数，分别是：

- 随机获取count个元素，集合元素个数不变

```
srandmember key [count]
```

- 随机弹出count个元素，元素从集合弹出，集合元素个数改变

```
spop key [count]
```

用户点击抽奖按钮，参数抽奖，将用户编号放入集合，然后抽奖，分别抽一等奖、二等奖，如果已经抽中一等奖的用户不能参数抽二等奖则使用`spop`，反之使用`srandmember`。


### **五 有序集合**



有序集合和集合一样，不能有重复元素。但是可以排序，它给每个元素设置一个score作为排序的依据。最多可以存储`2^32-1`个元素。


#### **5.1 内部编码**



有序集合类型的内部编码有两种：

- ziplist（压缩列表）：当有序集合的元素个数小于`list-max-ziplist-entries`配置（默认128个）同时所有值都小于`list-max-ziplist-value`配置（默认64字节）时使用。ziplist使用更加紧凑的结构实现多个元素的连续存储，更加节省内存。
- skiplist（跳跃表）：当不满足ziplist的要求时，会使用skiplist。

#### **5.2 使用场景**

##### 5.2.1 排行榜

用户发布了n篇文章，其他人看到文章后给喜欢的文章点赞，使用score来记录点赞数，有序集合会根据score排行。流程如下

用户发布一篇文章，初始点赞数为0，即score为0

```
zadd user:article 0 a
```

有人给文章a点赞，递增`1`

```
zincrby user:article 1 a
```

查询点赞前三篇文章

```
zrevrangebyscore user:article 0 2
```

查询点赞后三篇文章

```
zrangebyscore user:article 0 2
```

##### 5.2.2 延迟消息队列

下单系统，下单后需要在15分钟内进行支付，如果15分钟未支付则自动取消订单。将下单后的十五分钟后时间作为score，订单作为value存入redis，消费者轮询去消费，如果消费的大于等于这笔记录的score，则将这笔记录移除队列，取消订单。


### **总结**



在开发中，字符串类型是用的最多的数据类型，导致我们忽视了redis的其他四种数据类型，在具体场景下选择具体的数据类型对提升redis性能有非常大的帮助。redis虽然支持消息队列的实现，但是并不支持ack。所以redis实现的消息队列不能保证消息的可靠性，除非自己实现消息确认机制，不过这非常麻烦，所以如果是重要的消息还是推荐使用专门的消息队列去做，如RabbitMQ、RocketMQ。

******
参考链接：[Redis 五大数据类型使用场景](https://mp.weixin.qq.com/s/FsL-54ALoNUAPcft-u8Leg?v_p=86&WBAPIAnalysisOriUICodes=10000001_10000002&launchid=10000365--x&wm=3333_2001&aid=01A0GdQv0UejmN65Ntcd4pBeamMWOPan5tHaY8rK5tZGJgPOs.&from=10AA393010)  